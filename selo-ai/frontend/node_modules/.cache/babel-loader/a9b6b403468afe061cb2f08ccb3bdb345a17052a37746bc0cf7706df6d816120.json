{"ast":null,"code":"/**\n * Reflection Service\n * \n * Handles API communication with the reflection backend endpoints\n * and manages WebSocket connections for real-time reflection events.\n */import{io}from'socket.io-client';import{getApiBaseUrl}from'./config';// Socket.IO connection and status management\nlet socket=null;let connectionStatus='disconnected';let connectionListeners=new Set();let reflectionListeners=new Set();let currentUserId=null;let isConnecting=false;// prevent racing inits\nconst clientInstanceId=`reflect-${Math.random().toString(36).slice(2)}-${Date.now()}`;// Track whether a disconnect was initiated intentionally by the client (e.g., unmount)\nlet intentionalDisconnect=false;// Re-init throttling to avoid reconnection storms\nlet reinitScheduled=false;// Store callbacks for reconnection preservation\nlet storedOnReflectionUpdate=null;let storedOnConnectionStatus=null;const scheduleReinit=function(){let reason=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'unknown';if(reinitScheduled||isConnecting)return;reinitScheduled=true;try{console.warn('[ReflectionSocket] scheduling re-init due to:',reason);}catch(_){}setTimeout(()=>{try{if(socket){try{socket.removeAllListeners();}catch(_){}try{socket.disconnect();}catch(_){}}socket=null;// Re-initialize with the last known user id and preserved callbacks\n// Listeners are preserved via reflectionListeners set AND stored callbacks\nif(currentUserId){initReflectionSocket(currentUserId,storedOnReflectionUpdate,storedOnConnectionStatus);}}finally{reinitScheduled=false;}},1000);};/**\n * Subscribe to connection status changes\n * @param {function} callback - Callback function to receive status updates\n * @returns {function} Unsubscribe function\n */export const subscribeToConnectionStatus=callback=>{connectionListeners.add(callback);// Immediately call with current status\ncallback(connectionStatus);// Return unsubscribe function\nreturn()=>{connectionListeners.delete(callback);};};/**\n * Get current connection status\n * @returns {string} Current connection status\n */export const getConnectionStatus=()=>connectionStatus;/**\n * Update connection status and notify all listeners\n * @param {string} status - New connection status\n */const updateConnectionStatus=status=>{if(connectionStatus!==status){connectionStatus=status;connectionListeners.forEach(callback=>{try{callback(status);}catch(error){console.error('Error in connection status callback:',error);}});}};/**\n * Initialize WebSocket connection for real-time reflection events\n * @param {string} userId - User ID for authentication\n * @param {function} onReflectionUpdate - Callback when reflection updates occur\n * @param {function} onConnectionStatus - Callback for connection status changes (deprecated - use subscribeToConnectionStatus)\n * @returns {object} Socket instance\n */export const initReflectionSocket=(userId,onReflectionUpdate,onConnectionStatus)=>{// Do not start a socket connection without a valid user id\nif(!userId){try{console.warn('[ReflectionSocket] init aborted: missing userId');}catch(_){}return null;}// Store callbacks for reconnection preservation\nif(onReflectionUpdate)storedOnReflectionUpdate=onReflectionUpdate;if(onConnectionStatus)storedOnConnectionStatus=onConnectionStatus;// If a socket is already connecting or connected, avoid racing a new init\nif(socket&&(socket.connected||socket.connecting||isConnecting)){currentUserId=userId;try{socket.emit('authenticate',{user_id:userId});}catch(_){}return socket;}// Close existing idle/closed connection if any\nif(socket){try{socket.removeAllListeners();}catch(_){}try{socket.disconnect();}catch(_){}}// Define handlers before registration to avoid hoisting issues\nfunction handleGenerating(data){// Debug logging removed for production\nconst payload={status:'generating',type:data.reflection_type,data};onReflectionUpdate&&onReflectionUpdate(payload);reflectionListeners.forEach(cb=>{try{cb(payload);}catch(e){console.error(e);}});}function handleGenerated(data){const payload={status:'complete',type:data.reflection_type,reflectionId:data.reflection_id,data};onReflectionUpdate&&onReflectionUpdate(payload);reflectionListeners.forEach(cb=>{try{cb(payload);}catch(e){console.error(e);}});}// Connect to reflection namespace after runtime config is available\n// Lazy-init: resolve base URL asynchronously and then connect\ngetApiBaseUrl().then(API_BASE_URL=>{// Log the resolved API base URL for diagnostics\n// Debug logging removed for production\nisConnecting=true;socket=io(`${API_BASE_URL}/reflection`,{// Explicitly match backend Socket.IO path and force pure WebSocket (no polling)\npath:'/socket.io',transports:['websocket'],upgrade:false,autoConnect:true,reconnection:true,// Conservative timeouts/retry tuning\ntimeout:60000,// 60s connection timeout for slow networks/servers under load\nreconnectionAttempts:Infinity,reconnectionDelay:500,reconnectionDelayMax:5000});currentUserId=userId;// Set up event handlers after socket is created\nsocket.on('connect',()=>{// Debug logging removed for production\nupdateConnectionStatus('connected');onConnectionStatus&&onConnectionStatus('connected');// Backward compatibility\ntry{console.debug('[ReflectionSocket] connected',{clientInstanceId,sid:socket.id});}catch(_){}isConnecting=false;// Authenticate with the socket\nsocket.emit('authenticate',{user_id:userId});});socket.on('disconnect',reason=>{// Debug logging removed for production\nupdateConnectionStatus('disconnected');onConnectionStatus&&onConnectionStatus('disconnected');// Backward compatibility\ntry{console.debug('[ReflectionSocket] disconnected',{clientInstanceId,reason});}catch(_){}isConnecting=false;// If this was an intentional client disconnect (component unmount/navigation), do not re-init\nif(intentionalDisconnect){intentionalDisconnect=false;// reset flag\nreturn;}// If server restarted or transport closed, schedule a clean re-init\nif(reason==='transport error'||reason==='io server disconnect'||reason==='ping timeout'){scheduleReinit(`disconnect:${reason}`);}});// Additional diagnostics\nsocket.on('connect_error',err=>{console.error('Reflection WebSocket connect_error:',(err===null||err===void 0?void 0:err.message)||err,err);updateConnectionStatus('polling');isConnecting=false;// Common after restart or invalid sid; perform a clean re-init\nscheduleReinit('connect_error');});socket.io.on('reconnect_attempt',attempt=>{console.warn('Reflection WebSocket reconnect_attempt',attempt);updateConnectionStatus('polling');});socket.io.on('reconnect_error',err=>{console.error('Reflection WebSocket reconnect_error',(err===null||err===void 0?void 0:err.message)||err,err);updateConnectionStatus('polling');isConnecting=false;scheduleReinit('reconnect_error');});socket.io.on('reconnect_failed',()=>{console.error('Reflection WebSocket reconnect_failed');updateConnectionStatus('offline');isConnecting=false;scheduleReinit('reconnect_failed');});socket.on('ping',()=>{console.debug('Reflection WebSocket ping');});socket.on('pong',latency=>{console.debug('Reflection WebSocket pong',latency);});socket.on('authenticated',data=>{// Debug logging removed for production\n});socket.on('error',data=>{console.error('Reflection WebSocket error',data);// Some servers emit generic error on invalid sid; re-init defensively\nscheduleReinit('socket_error');});socket.on('reflection_generating',handleGenerating);socket.on('reflection_generated',handleGenerated);}).catch(e=>{console.error('Failed to initialize socket due to config error:',e);updateConnectionStatus('offline');});return socket;};/**\n * Disconnect WebSocket connection\n */export const disconnectReflectionSocket=()=>{if(socket){intentionalDisconnect=true;socket.disconnect();socket=null;updateConnectionStatus('disconnected');}};// Ensure we have a connected socket for a given user\nconst ensureSocket=userId=>{if(!socket){// Do not initialize without a valid user id; wait until it becomes available\nif(userId){initReflectionSocket(userId,null,null);}else{return;}}else if(userId&&currentUserId!==userId){try{socket.emit('authenticate',{user_id:userId});currentUserId=userId;}catch(e){console.error('Socket authenticate failed',e);}}};/**\n * Fetch list of reflections for a user\n * @param {string} userId - User ID\n * @param {string} reflectionType - Optional reflection type filter\n * @param {number} limit - Max number of reflections to fetch\n * @param {number} offset - Pagination offset\n * @returns {Promise<object>} Reflection list response\n */export const fetchReflections=async function(userId){let reflectionType=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:10;let offset=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;try{const API_BASE_URL=await getApiBaseUrl();let url=`${API_BASE_URL}/api/reflections/list?user_profile_id=${userId}&limit=${limit}&offset=${offset}`;if(reflectionType){url+=`&reflection_type=${reflectionType}`;}const response=await fetch(url);if(!response.ok){throw new Error(`API error: ${response.status}`);}return await response.json();}catch(error){console.error('Error fetching reflections:',error);throw error;}};/**\n * Fetch a specific reflection by ID\n * @param {string} reflectionId - Reflection ID\n * @returns {Promise<object>} Reflection data\n */export const fetchReflection=async reflectionId=>{try{const API_BASE_URL=await getApiBaseUrl();const response=await fetch(`${API_BASE_URL}/api/reflections/${reflectionId}`);if(!response.ok){throw new Error(`API error: ${response.status}`);}return await response.json();}catch(error){console.error(`Error fetching reflection ${reflectionId}:`,error);throw error;}};/**\n * [INTERNAL USE ONLY] Trigger a new reflection to be generated\n * This function is only for internal system use. User-triggered reflections are not supported.\n * Reflections are generated autonomously by the system scheduler.\n * \n * @private\n * @param {string} userId - User ID\n * @param {string} reflectionType - Type of reflection to generate\n * @param {string[]} memoryIds - Optional specific memory IDs to include\n * @returns {Promise<object>} Generation status\n */const _triggerReflection=async function(userId,reflectionType){let memoryIds=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;try{const API_BASE_URL=await getApiBaseUrl();const response=await fetch(`${API_BASE_URL}/api/reflections/generate`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_profile_id:userId,reflection_type:reflectionType,memory_ids:memoryIds,trigger_source:'system'})});if(!response.ok){throw new Error(`API error: ${response.status}`);}return await response.json();}catch(error){console.error('Error triggering reflection:',error);throw error;}};/**\n * [INTERNAL USE ONLY] Schedule a reflection for later generation\n * This function is only for internal system use. User scheduling is not supported.\n * Reflections are scheduled autonomously by the system.\n * \n * @private\n * @param {string} userId - User ID\n * @param {string} reflectionType - Type of reflection to schedule\n * @returns {Promise<object>} Schedule status\n */const _scheduleReflection=async(userId,reflectionType)=>{try{const API_BASE_URL=await getApiBaseUrl();const response=await fetch(`${API_BASE_URL}/api/reflections/schedule/${reflectionType}`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({user_profile_id:userId})});if(!response.ok){throw new Error(`API error: ${response.status}`);}return await response.json();}catch(error){console.error('Error scheduling reflection:',error);throw error;}};/**\n * [INTERNAL USE ONLY] Delete a reflection by ID\n * This function is only for internal system use.\n * To maintain a complete audit trail, users cannot delete reflections.\n * \n * @private\n * @param {string} reflectionId - Reflection ID\n * @returns {Promise<object>} Deletion status\n */const _deleteReflection=async reflectionId=>{try{const API_BASE_URL=await getApiBaseUrl();const response=await fetch(`${API_BASE_URL}/api/reflections/${reflectionId}`,{method:'DELETE'});if(!response.ok){throw new Error(`API error: ${response.status}`);}return await response.json();}catch(error){console.error(`Error deleting reflection ${reflectionId}:`,error);throw error;}};// Named service object used by components\nexport const reflectionService={getReflections:async function(userId){let reflectionType=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:20;let offset=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;const resp=await fetchReflections(userId,reflectionType,limit,offset);// Normalize to an array for consumers like ReflectionPanel\nif(Array.isArray(resp))return resp;return(resp===null||resp===void 0?void 0:resp.reflections)||[];},onReflectionGenerated:(callback,userId)=>{ensureSocket(userId);reflectionListeners.add(callback);return()=>reflectionListeners.delete(callback);},subscribeToConnectionStatus,getConnectionStatus,disconnect:()=>disconnectReflectionSocket(),init:(userId,onUpdate,onStatus)=>initReflectionSocket(userId,onUpdate,onStatus)};","map":{"version":3,"names":["io","getApiBaseUrl","socket","connectionStatus","connectionListeners","Set","reflectionListeners","currentUserId","isConnecting","clientInstanceId","Math","random","toString","slice","Date","now","intentionalDisconnect","reinitScheduled","storedOnReflectionUpdate","storedOnConnectionStatus","scheduleReinit","reason","arguments","length","undefined","console","warn","_","setTimeout","removeAllListeners","disconnect","initReflectionSocket","subscribeToConnectionStatus","callback","add","delete","getConnectionStatus","updateConnectionStatus","status","forEach","error","userId","onReflectionUpdate","onConnectionStatus","connected","connecting","emit","user_id","handleGenerating","data","payload","type","reflection_type","cb","e","handleGenerated","reflectionId","reflection_id","then","API_BASE_URL","path","transports","upgrade","autoConnect","reconnection","timeout","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","on","debug","sid","id","err","message","attempt","latency","catch","disconnectReflectionSocket","ensureSocket","fetchReflections","reflectionType","limit","offset","url","response","fetch","ok","Error","json","fetchReflection","_triggerReflection","memoryIds","method","headers","body","JSON","stringify","user_profile_id","memory_ids","trigger_source","_scheduleReflection","_deleteReflection","reflectionService","getReflections","resp","Array","isArray","reflections","onReflectionGenerated","init","onUpdate","onStatus"],"sources":["/mnt/local/Projects/SELODSP1/selo-ai/frontend/src/services/reflectionService.js"],"sourcesContent":["/**\n * Reflection Service\n * \n * Handles API communication with the reflection backend endpoints\n * and manages WebSocket connections for real-time reflection events.\n */\n\nimport { io } from 'socket.io-client';\nimport { getApiBaseUrl } from './config';\n\n// Socket.IO connection and status management\nlet socket = null;\nlet connectionStatus = 'disconnected';\nlet connectionListeners = new Set();\nlet reflectionListeners = new Set();\nlet currentUserId = null;\nlet isConnecting = false; // prevent racing inits\nconst clientInstanceId = `reflect-${Math.random().toString(36).slice(2)}-${Date.now()}`;\n// Track whether a disconnect was initiated intentionally by the client (e.g., unmount)\nlet intentionalDisconnect = false;\n// Re-init throttling to avoid reconnection storms\nlet reinitScheduled = false;\n// Store callbacks for reconnection preservation\nlet storedOnReflectionUpdate = null;\nlet storedOnConnectionStatus = null;\nconst scheduleReinit = (reason = 'unknown') => {\n  if (reinitScheduled || isConnecting) return;\n  reinitScheduled = true;\n  try { console.warn('[ReflectionSocket] scheduling re-init due to:', reason); } catch (_) {}\n  setTimeout(() => {\n    try {\n      if (socket) {\n        try { socket.removeAllListeners(); } catch (_) {}\n        try { socket.disconnect(); } catch (_) {}\n      }\n      socket = null;\n      // Re-initialize with the last known user id and preserved callbacks\n      // Listeners are preserved via reflectionListeners set AND stored callbacks\n      if (currentUserId) {\n        initReflectionSocket(currentUserId, storedOnReflectionUpdate, storedOnConnectionStatus);\n      }\n    } finally {\n      reinitScheduled = false;\n    }\n  }, 1000);\n};\n\n/**\n * Subscribe to connection status changes\n * @param {function} callback - Callback function to receive status updates\n * @returns {function} Unsubscribe function\n */\nexport const subscribeToConnectionStatus = (callback) => {\n  connectionListeners.add(callback);\n  // Immediately call with current status\n  callback(connectionStatus);\n  \n  // Return unsubscribe function\n  return () => {\n    connectionListeners.delete(callback);\n  };\n};\n\n/**\n * Get current connection status\n * @returns {string} Current connection status\n */\nexport const getConnectionStatus = () => connectionStatus;\n\n/**\n * Update connection status and notify all listeners\n * @param {string} status - New connection status\n */\nconst updateConnectionStatus = (status) => {\n  if (connectionStatus !== status) {\n    connectionStatus = status;\n    connectionListeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Error in connection status callback:', error);\n      }\n    });\n  }\n};\n\n/**\n * Initialize WebSocket connection for real-time reflection events\n * @param {string} userId - User ID for authentication\n * @param {function} onReflectionUpdate - Callback when reflection updates occur\n * @param {function} onConnectionStatus - Callback for connection status changes (deprecated - use subscribeToConnectionStatus)\n * @returns {object} Socket instance\n */\nexport const initReflectionSocket = (userId, onReflectionUpdate, onConnectionStatus) => {\n  // Do not start a socket connection without a valid user id\n  if (!userId) {\n    try { console.warn('[ReflectionSocket] init aborted: missing userId'); } catch (_) {}\n    return null;\n  }\n  // Store callbacks for reconnection preservation\n  if (onReflectionUpdate) storedOnReflectionUpdate = onReflectionUpdate;\n  if (onConnectionStatus) storedOnConnectionStatus = onConnectionStatus;\n  \n  // If a socket is already connecting or connected, avoid racing a new init\n  if (socket && (socket.connected || socket.connecting || isConnecting)) {\n    currentUserId = userId;\n    try { socket.emit('authenticate', { user_id: userId }); } catch (_) {}\n    return socket;\n  }\n  // Close existing idle/closed connection if any\n  if (socket) {\n    try { socket.removeAllListeners(); } catch (_) {}\n    try { socket.disconnect(); } catch (_) {}\n  }\n  \n  // Define handlers before registration to avoid hoisting issues\n  function handleGenerating(data) {\n    // Debug logging removed for production\n    const payload = {\n      status: 'generating',\n      type: data.reflection_type,\n      data\n    };\n    onReflectionUpdate && onReflectionUpdate(payload);\n    reflectionListeners.forEach(cb => {\n      try { cb(payload); } catch (e) { console.error(e); }\n    });\n  }\n\n  function handleGenerated(data) {\n    const payload = {\n      status: 'complete',\n      type: data.reflection_type,\n      reflectionId: data.reflection_id,\n      data\n    };\n    onReflectionUpdate && onReflectionUpdate(payload);\n    reflectionListeners.forEach(cb => {\n      try { cb(payload); } catch (e) { console.error(e); }\n    });\n  }\n\n  // Connect to reflection namespace after runtime config is available\n  // Lazy-init: resolve base URL asynchronously and then connect\n  getApiBaseUrl()\n    .then((API_BASE_URL) => {\n      // Log the resolved API base URL for diagnostics\n      // Debug logging removed for production\n      isConnecting = true;\n      socket = io(`${API_BASE_URL}/reflection`, {\n        // Explicitly match backend Socket.IO path and force pure WebSocket (no polling)\n        path: '/socket.io',\n        transports: ['websocket'],\n        upgrade: false,\n        autoConnect: true,\n        reconnection: true,\n        // Conservative timeouts/retry tuning\n        timeout: 60000, // 60s connection timeout for slow networks/servers under load\n        reconnectionAttempts: Infinity,\n        reconnectionDelay: 500,\n        reconnectionDelayMax: 5000,\n      });\n      currentUserId = userId;\n      \n      // Set up event handlers after socket is created\n      socket.on('connect', () => {\n        // Debug logging removed for production\n        updateConnectionStatus('connected');\n        onConnectionStatus && onConnectionStatus('connected'); // Backward compatibility\n        try { console.debug('[ReflectionSocket] connected', { clientInstanceId, sid: socket.id }); } catch (_) {}\n        isConnecting = false;\n        // Authenticate with the socket\n        socket.emit('authenticate', { user_id: userId });\n      });\n      \n      socket.on('disconnect', (reason) => {\n        // Debug logging removed for production\n        updateConnectionStatus('disconnected');\n        onConnectionStatus && onConnectionStatus('disconnected'); // Backward compatibility\n        try { console.debug('[ReflectionSocket] disconnected', { clientInstanceId, reason }); } catch (_) {}\n        isConnecting = false;\n        // If this was an intentional client disconnect (component unmount/navigation), do not re-init\n        if (intentionalDisconnect) {\n          intentionalDisconnect = false; // reset flag\n          return;\n        }\n        // If server restarted or transport closed, schedule a clean re-init\n        if (reason === 'transport error' || reason === 'io server disconnect' || reason === 'ping timeout') {\n          scheduleReinit(`disconnect:${reason}`);\n        }\n      });\n\n      // Additional diagnostics\n      socket.on('connect_error', (err) => {\n        console.error('Reflection WebSocket connect_error:', err?.message || err, err);\n        updateConnectionStatus('polling');\n        isConnecting = false;\n        // Common after restart or invalid sid; perform a clean re-init\n        scheduleReinit('connect_error');\n      });\n      socket.io.on('reconnect_attempt', (attempt) => {\n        console.warn('Reflection WebSocket reconnect_attempt', attempt);\n        updateConnectionStatus('polling');\n      });\n      socket.io.on('reconnect_error', (err) => {\n        console.error('Reflection WebSocket reconnect_error', err?.message || err, err);\n        updateConnectionStatus('polling');\n        isConnecting = false;\n        scheduleReinit('reconnect_error');\n      });\n      socket.io.on('reconnect_failed', () => {\n        console.error('Reflection WebSocket reconnect_failed');\n        updateConnectionStatus('offline');\n        isConnecting = false;\n        scheduleReinit('reconnect_failed');\n      });\n      socket.on('ping', () => {\n        console.debug('Reflection WebSocket ping');\n      });\n      socket.on('pong', (latency) => {\n        console.debug('Reflection WebSocket pong', latency);\n      });\n      \n      socket.on('authenticated', (data) => {\n        // Debug logging removed for production\n      });\n      \n      socket.on('error', (data) => {\n        console.error('Reflection WebSocket error', data);\n        // Some servers emit generic error on invalid sid; re-init defensively\n        scheduleReinit('socket_error');\n      });\n      \n      socket.on('reflection_generating', handleGenerating);\n      socket.on('reflection_generated', handleGenerated);\n    })\n    .catch((e) => {\n      console.error('Failed to initialize socket due to config error:', e);\n      updateConnectionStatus('offline');\n    });\n  \n  return socket;\n};\n\n/**\n * Disconnect WebSocket connection\n */\nexport const disconnectReflectionSocket = () => {\n  if (socket) {\n    intentionalDisconnect = true;\n    socket.disconnect();\n    socket = null;\n    updateConnectionStatus('disconnected');\n  }\n};\n\n// Ensure we have a connected socket for a given user\nconst ensureSocket = (userId) => {\n  if (!socket) {\n    // Do not initialize without a valid user id; wait until it becomes available\n    if (userId) {\n      initReflectionSocket(userId, null, null);\n    } else {\n      return;\n    }\n  } else if (userId && currentUserId !== userId) {\n    try {\n      socket.emit('authenticate', { user_id: userId });\n      currentUserId = userId;\n    } catch (e) {\n      console.error('Socket authenticate failed', e);\n    }\n  }\n};\n\n/**\n * Fetch list of reflections for a user\n * @param {string} userId - User ID\n * @param {string} reflectionType - Optional reflection type filter\n * @param {number} limit - Max number of reflections to fetch\n * @param {number} offset - Pagination offset\n * @returns {Promise<object>} Reflection list response\n */\nexport const fetchReflections = async (userId, reflectionType = null, limit = 10, offset = 0) => {\n  try {\n    const API_BASE_URL = await getApiBaseUrl();\n    let url = `${API_BASE_URL}/api/reflections/list?user_profile_id=${userId}&limit=${limit}&offset=${offset}`;\n    \n    if (reflectionType) {\n      url += `&reflection_type=${reflectionType}`;\n    }\n    \n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error fetching reflections:', error);\n    throw error;\n  }\n};\n\n/**\n * Fetch a specific reflection by ID\n * @param {string} reflectionId - Reflection ID\n * @returns {Promise<object>} Reflection data\n */\nexport const fetchReflection = async (reflectionId) => {\n  try {\n    const API_BASE_URL = await getApiBaseUrl();\n    const response = await fetch(`${API_BASE_URL}/api/reflections/${reflectionId}`);\n    \n    if (!response.ok) {\n      throw new Error(`API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error(`Error fetching reflection ${reflectionId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * [INTERNAL USE ONLY] Trigger a new reflection to be generated\n * This function is only for internal system use. User-triggered reflections are not supported.\n * Reflections are generated autonomously by the system scheduler.\n * \n * @private\n * @param {string} userId - User ID\n * @param {string} reflectionType - Type of reflection to generate\n * @param {string[]} memoryIds - Optional specific memory IDs to include\n * @returns {Promise<object>} Generation status\n */\nconst _triggerReflection = async (userId, reflectionType, memoryIds = null) => {\n  try {\n    const API_BASE_URL = await getApiBaseUrl();\n    const response = await fetch(`${API_BASE_URL}/api/reflections/generate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        user_profile_id: userId,\n        reflection_type: reflectionType,\n        memory_ids: memoryIds,\n        trigger_source: 'system'\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error triggering reflection:', error);\n    throw error;\n  }\n};\n\n/**\n * [INTERNAL USE ONLY] Schedule a reflection for later generation\n * This function is only for internal system use. User scheduling is not supported.\n * Reflections are scheduled autonomously by the system.\n * \n * @private\n * @param {string} userId - User ID\n * @param {string} reflectionType - Type of reflection to schedule\n * @returns {Promise<object>} Schedule status\n */\nconst _scheduleReflection = async (userId, reflectionType) => {\n  try {\n    const API_BASE_URL = await getApiBaseUrl();\n    const response = await fetch(`${API_BASE_URL}/api/reflections/schedule/${reflectionType}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        user_profile_id: userId\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error scheduling reflection:', error);\n    throw error;\n  }\n};\n\n/**\n * [INTERNAL USE ONLY] Delete a reflection by ID\n * This function is only for internal system use.\n * To maintain a complete audit trail, users cannot delete reflections.\n * \n * @private\n * @param {string} reflectionId - Reflection ID\n * @returns {Promise<object>} Deletion status\n */\nconst _deleteReflection = async (reflectionId) => {\n  try {\n    const API_BASE_URL = await getApiBaseUrl();\n    const response = await fetch(`${API_BASE_URL}/api/reflections/${reflectionId}`, {\n      method: 'DELETE'\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error(`Error deleting reflection ${reflectionId}:`, error);\n    throw error;\n  }\n};\n\n// Named service object used by components\nexport const reflectionService = {\n  getReflections: async (userId, reflectionType = null, limit = 20, offset = 0) => {\n    const resp = await fetchReflections(userId, reflectionType, limit, offset);\n    // Normalize to an array for consumers like ReflectionPanel\n    if (Array.isArray(resp)) return resp;\n    return resp?.reflections || [];\n  },\n\n  onReflectionGenerated: (callback, userId) => {\n    ensureSocket(userId);\n    reflectionListeners.add(callback);\n    return () => reflectionListeners.delete(callback);\n  },\n\n  subscribeToConnectionStatus,\n  getConnectionStatus,\n  disconnect: () => disconnectReflectionSocket(),\n  init: (userId, onUpdate, onStatus) => initReflectionSocket(userId, onUpdate, onStatus),\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}